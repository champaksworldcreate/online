<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Whiteboard — Fixed</title>
<style>
  :root{
    --bg:#eef3ff; --panel:#fff; --accent:#3f6bff; --muted:#8b9cff;
    --toolbar-h:56px;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Arial,Helvetica,sans-serif;background:var(--bg);color:#0b2545}
  .app { height:100vh; display:flex; flex-direction:column; }

  /* Top toolbar */
  .toolbar { height:var(--toolbar-h); display:flex; gap:8px; align-items:center; padding:8px; background:linear-gradient(180deg,#fff,#f5f9ff); border-bottom:1px solid rgba(0,0,0,0.04); flex-shrink:0; }
  .toolbar .group{ display:flex; gap:8px; align-items:center; }
  .toolbar button, .toolbar input[type="color"], .toolbar input[type="range"], .toolbar select { background:white;border:1px solid rgba(0,0,0,0.06); padding:8px 10px; border-radius:8px; cursor:pointer; font-size:13px; }
  .toolbar .spacer { flex:1; }

  /* Layout area */
  .layout { display:flex; flex:1; gap:12px; padding:12px; box-sizing:border-box; }

  /* Left tools column (drawing tools) */
  .leftcol { width:88px; min-width:72px; display:flex; flex-direction:column; gap:8px; align-items:center; }
  .toolbtn { width:64px; text-align:center; padding:8px; border-radius:8px; background:white; border:1px solid rgba(0,0,0,0.06); cursor:pointer; font-size:13px; }
  .toolbtn.active { box-shadow:0 6px 18px rgba(63,107,255,0.12); border-color:var(--accent); }

  /* Stage wrapper (with pan transform applied) */
  .stage-viewport { flex:1; border-radius:12px; background:linear-gradient(180deg,#ffffff,#fbfdff); border:3px solid var(--accent); overflow:hidden; position:relative; min-height:300px; }

  /* world (big drawing area). We'll size this on resize. */
  .world { position:absolute; left:0; top:0; transform-origin:0 0; will-change:transform; background-size: 20px 20px, 20px 20px; }
  .world.grid { background-image: linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px), linear-gradient(rgba(0,0,0,0.02) 1px, transparent 1px); }
  .world.nogrid { background-image: none; }

  /* objects layer sits inside world */
  .objects-layer { position:absolute; left:0; top:0; pointer-events:auto; }

  /* drawing canvas overlays objects (kept in world coords) */
  canvas.draw-layer { position:absolute; left:0; top:0; display:block; }

  /* object styles */
  .obj { position:absolute; box-sizing:border-box; transform-origin:center center; touch-action:none; user-select:none; transition: box-shadow .12s ease; }
  .obj .content { width:100%; height:100%; display:flex; align-items:center; justify-content:center; overflow:hidden; }
  .obj.rect{ background: rgba(63,107,255,0.06); border:2px solid rgba(63,107,255,0.18); border-radius:8px; }
  .obj.circle{ background: rgba(255,200,60,0.10); border:2px solid rgba(255,180,0,0.22); border-radius:999px; }
  .obj.text{ background:transparent; border:1px dashed rgba(0,0,0,0.06); padding:6px 8px; font-size:16px; }
  .obj img{ width:100%; height:100%; object-fit:cover; display:block; border-radius:6px; }

  .obj.selected{ box-shadow:0 12px 30px rgba(16,24,40,0.12); outline:2px solid rgba(63,107,255,0.10); }

  /* handles: rotate top-center and resize bottom-right */
  .handle { position:absolute; width:12px; height:12px; background:white; border:2px solid rgba(0,0,0,0.12); border-radius:3px; box-sizing:border-box; z-index:40; }
  .handle.rotate { top:-20px; left:50%; transform:translateX(-50%); cursor:grab; }
  .handle.resize { right:-10px; bottom:-10px; cursor:se-resize; }

  /* selection rectangle */
  .sel-rect { position:fixed; border:1px dashed rgba(0,0,0,0.25); background: rgba(63,107,255,0.06); pointer-events:none; z-index:20000; display:none; }

  /* bottom-right guide (fixed) */
  .guide { position:fixed; right:12px; bottom:12px; width:320px; background:#fff; border-radius:12px; box-shadow:0 14px 40px rgba(31,41,55,0.12); z-index:10020; padding:0; border:1px solid rgba(63,107,255,0.12); font-size:13px; }
  .guide .head{ display:flex; justify-content:space-between; align-items:center; padding:10px; border-bottom:1px solid rgba(0,0,0,0.04); }
  .guide .content{ padding:10px; max-height:320px; overflow:auto; }
  .guide.collapsed{ width:48px; height:48px; border-radius:50%; padding:0; display:flex; align-items:center; justify-content:center; }
  #helpBtn { position:fixed; right:12px; bottom:12px; width:48px; height:48px; border-radius:50%; border:2px solid rgba(63,107,255,0.25); background:white; font-size:20px; display:none; z-index:10025; }

  /* responsive: collapse left tools into top toolbar on very small screens */
  @media (max-width:920px){ .layout { padding:8px; gap:8px; } .leftcol { display:none; } .toolbar { flex-wrap:wrap; } }
  @media (max-width:520px){ .guide { width:92%; right:4%; left:4%; bottom:12px; } #helpBtn { right:14px; bottom:14px; } }

  .small{ font-size:13px; padding:6px 8px }
</style>
</head>
<body>
<div class="app">

  <!-- top toolbar -->
  <div class="toolbar" role="toolbar" aria-label="Main toolbar">
    <div class="group">
      <button id="addRect" class="small">Add Rect</button>
      <button id="addCircle" class="small">Add Circle</button>
      <button id="addText" class="small">Add Text</button>
      <button id="addImage" class="small">Add Image</button>
      <button id="dupBtn" class="small" title="Duplicate (Ctrl/Cmd+D)">Duplicate</button>
    </div>

    <div class="group">
      <button id="toggleGrid" class="small">Toggle Grid</button>
      <label class="small">Grid:</label>
      <select id="gridSize" class="small">
        <option value="8">8px</option>
        <option value="12" selected>12px</option>
        <option value="20">20px</option>
        <option value="32">32px</option>
      </select>
      <label class="small">Snap</label>
      <input type="checkbox" id="snapToggle" checked>
    </div>

    <div class="group">
      <button id="exportJSON" class="small">Export JSON</button>
      <button id="importJSONbtn" class="small">Import JSON</button>
      <input id="importJSONfile" type="file" accept="application/json" style="display:none">
      <button id="clearAll" class="small">Clear All</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <label class="small">Color</label>
      <input id="penColor" type="color" value="#000000">
      <label class="small">Size</label>
      <input id="penSize" type="range" min="1" max="80" value="6">
      <label class="small">Opacity</label>
      <input id="penOpacity" type="range" min="0.1" max="1" step="0.05" value="1">
    </div>
  </div>

  <!-- main layout -->
  <div class="layout">

    <!-- left column: drawing tools -->
    <div class="leftcol" aria-hidden="false">
      <div id="penTool" class="toolbtn active" title="Pen">Pen</div>
      <div id="highlighterTool" class="toolbtn">Highlighter</div>
      <div id="eraserTool" class="toolbtn">Eraser</div>
      <div id="selectTool" class="toolbtn">Select</div>
      <div id="panHint" style="margin-top:6px;font-size:12px;color:#334">Hold <b>Space</b> to Pan</div>
    </div>

    <!-- stage viewport -->
    <div class="stage-viewport" id="viewport" tabindex="0" aria-label="Whiteboard viewport">
      <!-- world (will be sized dynamically) -->
      <div class="world nogrid" id="world">
        <!-- drawing layer canvas (will match world size) -->
        <canvas id="drawing" class="draw-layer"></canvas>

        <!-- objects layer -->
        <div id="objectsLayer" class="objects-layer"></div>
      </div>
    </div>
  </div>

  <!-- guide (bottom-right) -->
  <aside id="guide" class="guide" role="region" aria-label="How to use guide">
    <div class="head">
      <div>
        <strong>How to use — Whiteboard</strong><br><small style="color:#445">Quick tips</small>
      </div>
      <div>
        <button id="collapseGuide" class="small">–</button>
        <button id="closeGuide" class="small">✕</button>
      </div>
    </div>
    <div class="content" id="guideContent">
      <h4>Basic</h4>
      <ul>
        <li>Add objects (rect/circle/text/image) from the toolbar.</li>
        <li>Select an object to move, resize (bottom-right), or rotate (top-center).</li>
        <li>Multi-select: <b>Shift + Click</b> or use selection box (Select tool).</li>
        <li>Duplicate selected: <b>Ctrl/Cmd + D</b>. Delete: <b>Delete</b>.</li>
      </ul>

      <h4>Grid & Snap</h4>
      <ul><li>Toggle grid and pick grid size. When Snap is ON, move/resize/rotate will snap to grid/steps.</li></ul>

      <h4>Pan & Draw</h4>
      <ul>
        <li>Hold the <b>Space</b> key and drag background to pan the canvas (objects & drawing move together).</li>
        <li>Pick drawing tool (Pen / Highlighter / Eraser) then draw with pointer.</li>
      </ul>

      <h4>Export / Import</h4>
      <ul><li>Export JSON saves objects (positions, size, rotation, html). Import restores them.</li></ul>
    </div>
  </aside>

  <button id="helpBtn">?</button>
  <div id="selRect" class="sel-rect"></div>
</div>

<script>
/* Fixed advanced whiteboard
   - Multi-select & selection rectangle
   - Proper drag/resize/rotate math (world coordinates)
   - Eraser works on drawing layer
   - Duplicate (Ctrl/Cmd+D) for all selected
   - Clear All (objects + drawing)
   - Guide with restore via localStorage
*/

/* --------------------
   DOM & state
   -------------------- */
const viewport = document.getElementById('viewport');
const world = document.getElementById('world');
const objectsLayer = document.getElementById('objectsLayer');
const drawingCanvas = document.getElementById('drawing');
const selRect = document.getElementById('selRect');
const ctx = drawingCanvas.getContext('2d', { alpha: true });

const penToolBtn = document.getElementById('penTool');
const highlighterToolBtn = document.getElementById('highlighterTool');
const eraserToolBtn = document.getElementById('eraserTool');
const selectToolBtn = document.getElementById('selectTool');

const penColor = document.getElementById('penColor');
const penSize = document.getElementById('penSize');
const penOpacity = document.getElementById('penOpacity');

const toggleGridBtn = document.getElementById('toggleGrid');
const gridSizeSelect = document.getElementById('gridSize');
const snapToggle = document.getElementById('snapToggle');

const exportJSONBtn = document.getElementById('exportJSON');
const importJSONbtn = document.getElementById('importJSONbtn');
const importJSONfile = document.getElementById('importJSONfile');

const helpBtn = document.getElementById('helpBtn');
const guide = document.getElementById('guide');
const collapseGuide = document.getElementById('collapseGuide');
const closeGuide = document.getElementById('closeGuide');

let worldW = 2400, worldH = 1600;
function resizeWorld(){
  const vw = viewport.clientWidth, vh = viewport.clientHeight;
  worldW = Math.max(1400, Math.floor(vw * 2));
  worldH = Math.max(900, Math.floor(vh * 2));
  world.style.width = worldW + 'px';
  world.style.height = worldH + 'px';
  objectsLayer.style.width = worldW + 'px';
  objectsLayer.style.height = worldH + 'px';
  drawingCanvas.width = worldW;
  drawingCanvas.height = worldH;
  drawingCanvas.style.width = worldW + 'px';
  drawingCanvas.style.height = worldH + 'px';
  // preserve existing bitmap drawn to canvas remains (we do not scale it here)
}
window.addEventListener('resize', resizeWorld);
resizeWorld();

/* transform (pan + scale) */
let pan = { x: 0, y: 0 };
let scale = 1;
function applyTransform(){
  world.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
  // objectsLayer & drawing are inside world so transform applies to them automatically
}
applyTransform();

/* helpers page <-> world coordinates */
function pageToWorld(clientX, clientY){
  const r = viewport.getBoundingClientRect();
  const x = (clientX - r.left - pan.x) / scale;
  const y = (clientY - r.top - pan.y) / scale;
  return { x, y };
}
function worldToPage(wx, wy){
  const r = viewport.getBoundingClientRect();
  return { x: r.left + pan.x + wx*scale, y: r.top + pan.y + wy*scale };
}

/* snapping helpers */
function snapValue(v){
  if(!snapToggle.checked) return v;
  const g = parseInt(gridSizeSelect.value,10) || 12;
  return Math.round(v / g) * g;
}
function snapAngle(a){
  if(!snapToggle.checked) return a;
  const step = 15;
  return Math.round(a / step) * step;
}

/* --------------------
   Drawing tools (pen/highlighter/eraser)
   Drawing coordinates are in world space and drawn directly into the canvas bitmap.
   -------------------- */
let drawMode = 'pen'; // 'pen'|'highlighter'|'eraser'|'select'
function setActiveTool(t){
  drawMode = t;
  [penToolBtn, highlighterToolBtn, eraserToolBtn, selectToolBtn].forEach(b=>b.classList.remove('active'));
  if(t==='pen') penToolBtn.classList.add('active');
  if(t==='highlighter') highlighterToolBtn.classList.add('active');
  if(t==='eraser') eraserToolBtn.classList.add('active');
  if(t==='select') selectToolBtn.classList.add('active');
}
penToolBtn.addEventListener('click', ()=> setActiveTool('pen'));
highlighterToolBtn.addEventListener('click', ()=> setActiveTool('highlighter'));
eraserToolBtn.addEventListener('click', ()=> setActiveTool('eraser'));
selectToolBtn.addEventListener('click', ()=> setActiveTool('select'));

let isDrawing = false;
let lastPoint = null;

function startDrawAt(worldPt){
  isDrawing = true;
  lastPoint = worldPt;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(worldPt.x, worldPt.y);
}
function continueDrawTo(worldPt){
  if(!isDrawing || !lastPoint) return;
  const size = Number(penSize.value);
  if(drawMode === 'eraser'){
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineWidth = size;
    ctx.strokeStyle = 'rgba(0,0,0,1)';
    ctx.lineTo(worldPt.x, worldPt.y);
    ctx.stroke();
    ctx.restore();
  } else if(drawMode === 'highlighter'){
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = Number(penOpacity.value) * 0.45;
    ctx.lineWidth = size * 2;
    ctx.strokeStyle = penColor.value;
    ctx.lineTo(worldPt.x, worldPt.y);
    ctx.stroke();
    ctx.restore();
  } else { // pen
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = Number(penOpacity.value);
    ctx.lineWidth = size;
    ctx.strokeStyle = penColor.value;
    ctx.lineTo(worldPt.x, worldPt.y);
    ctx.stroke();
    ctx.restore();
  }
  lastPoint = worldPt;
}
function endDraw(){ isDrawing = false; lastPoint = null; }

/* --------------------
   Pan & pointer behavior
   -------------------- */
let spaceDown = false;
let panning = false, panStart = null, savedPan = null;

/* selection rectangle (multi-select) state */
let selecting = false;
let selStart = null;

viewport.addEventListener('pointerdown', (ev)=>{
  viewport.focus();
  // pan by holding space
  if(spaceDown){
    panning = true; panStart = { x: ev.clientX, y: ev.clientY }; savedPan = { x: pan.x, y: pan.y }; viewport.style.cursor = 'grabbing'; ev.preventDefault(); return;
  }
  // if select tool and clicked empty area -> start selection rectangle
  if(drawMode === 'select' && (ev.target === viewport || ev.target === world || ev.target === drawingCanvas)){
    selecting = true;
    selStart = { x: ev.clientX, y: ev.clientY };
    selRect.style.left = selStart.x + 'px'; selRect.style.top = selStart.y + 'px';
    selRect.style.width = '0px'; selRect.style.height = '0px'; selRect.style.display = 'block';
    ev.preventDefault();
    return;
  }
  // drawing tools
  if(drawMode === 'pen' || drawMode === 'highlighter' || drawMode === 'eraser'){
    const wpt = pageToWorld(ev.clientX, ev.clientY);
    startDrawAt(wpt);
    ev.preventDefault();
  }
});

window.addEventListener('pointermove', (ev)=>{
  if(panning){
    pan.x = savedPan.x + (ev.clientX - panStart.x);
    pan.y = savedPan.y + (ev.clientY - panStart.y);
    applyTransform();
    return;
  }
  if(selecting && selStart){
    const x = Math.min(selStart.x, ev.clientX), y = Math.min(selStart.y, ev.clientY);
    const w = Math.abs(ev.clientX - selStart.x), h = Math.abs(ev.clientY - selStart.y);
    selRect.style.left = x + 'px'; selRect.style.top = y + 'px'; selRect.style.width = w + 'px'; selRect.style.height = h + 'px';
    return;
  }
  if(isDrawing){
    const wpt = pageToWorld(ev.clientX, ev.clientY);
    continueDrawTo(wpt);
  }
});

window.addEventListener('pointerup', (ev)=>{
  if(panning){ panning = false; viewport.style.cursor = 'default'; return; }
  if(selecting){ finalizeSelectionRect(); selecting = false; selRect.style.display = 'none'; selStart = null; return; }
  if(isDrawing){ endDraw(); }
});

/* keyboard shortcuts */
window.addEventListener('keydown', (ev)=>{
  if(ev.code === 'Space'){ spaceDown = true; viewport.style.cursor='grab'; ev.preventDefault(); }
  if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase()==='d'){ duplicateSelected(); ev.preventDefault(); }
  if(ev.key === 'Delete' || ev.key === 'Backspace'){ deleteSelected(); ev.preventDefault(); }
});
window.addEventListener('keyup', (ev)=>{ if(ev.code === 'Space'){ spaceDown = false; viewport.style.cursor='default'; } });

/* --------------------
   Objects: multi-select, create, transform
   -------------------- */
let selectedSet = new Set();
let selectionOrder = []; // maintain order for duplication
let objectCounter = 1, zCounter = 1;

function addToSelection(el){
  if(!el) return;
  if(!selectedSet.has(el)){ selectedSet.add(el); selectionOrder.push(el); el.classList.add('selected'); }
}
function removeFromSelection(el){
  if(!el) return;
  if(selectedSet.has(el)){ selectedSet.delete(el); selectionOrder = selectionOrder.filter(x=>x!==el); el.classList.remove('selected'); }
}
function clearSelection(){
  for(const el of Array.from(selectedSet)) el.classList.remove('selected');
  selectedSet.clear(); selectionOrder = [];
}
function getSelectionArray(){ return Array.from(selectionOrder); }

function selectObjectSingle(el, append=false){
  if(append){
    if(selectedSet.has(el)) removeFromSelection(el); else addToSelection(el);
  } else {
    clearSelection();
    if(el) addToSelection(el);
  }
}

/* create object */
function createObject({ x=120, y=80, w=220, h=120, type='rect', html='' } = {}){
  const el = document.createElement('div');
  el.className = 'obj ' + (type==='circle' ? 'circle' : type==='text' ? 'text' : 'rect');
  el.dataset.objId = 'obj' + (objectCounter++);
  el.style.left = x + 'px'; el.style.top = y + 'px';
  el.style.width = w + 'px'; el.style.height = h + 'px';
  el.style.transform = 'rotate(0deg)'; el.style.zIndex = ++zCounter;
  el.dataset.angle = '0';

  const content = document.createElement('div'); content.className = 'content'; content.innerHTML = html || (type==='text' ? 'Double-click to edit' : '');
  el.appendChild(content);

  const rotateHandle = document.createElement('div'); rotateHandle.className = 'handle rotate'; el.appendChild(rotateHandle);
  const resizeHandle = document.createElement('div'); resizeHandle.className = 'handle resize'; el.appendChild(resizeHandle);

  makeInteractiveObject(el, rotateHandle, resizeHandle);

  objectsLayer.appendChild(el);
  selectObjectSingle(el);
  return el;
}

/* selection rectangle finalizer — picks objects intersecting rectangle */
function finalizeSelectionRect(){
  if(!selRect) return;
  const rectPage = selRect.getBoundingClientRect();
  const vpRect = viewport.getBoundingClientRect();
  const worldRect = {
    left: (rectPage.left - vpRect.left - pan.x) / scale,
    top:  (rectPage.top - vpRect.top  - pan.y) / scale,
    right: (rectPage.right - vpRect.left - pan.x) / scale,
    bottom: (rectPage.bottom - vpRect.top - pan.y) / scale
  };
  const els = Array.from(objectsLayer.children).filter(e=>e.classList && e.classList.contains('obj'));
  // Shift key: add to selection; otherwise replace
  const append = (window.event && window.event.shiftKey) || false;
  if(!append) clearSelection();
  for(const el of els){
    const l = parseFloat(el.style.left), t = parseFloat(el.style.top), w = parseFloat(el.style.width), h = parseFloat(el.style.height);
    const r = l + w, b = t + h;
    const intersects = !(r < worldRect.left || l > worldRect.right || b < worldRect.top || t > worldRect.bottom);
    if(intersects) addToSelection(el);
  }
}

/* make object interactive: drag/resize/rotate + selection behaviors */
function makeInteractiveObject(el, rotateHandle, resizeHandle){
  // drag (supports group movement)
  let dragging=false, dragStart=null, groupOrig=null;
  el.addEventListener('pointerdown', (ev)=>{
    if(ev.button && ev.button !== 0) return;
    if(ev.target === rotateHandle || ev.target === resizeHandle) return;
    ev.stopPropagation();
    // determine selection: shift toggles membership
    if(ev.shiftKey) selectObjectSingle(el, true);
    else if(!selectedSet.has(el)) selectObjectSingle(el, false);
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    dragging = true;
    dragStart = { x: ev.clientX, y: ev.clientY };
    // record origins for all selected to support group move
    groupOrig = getSelectionArray().map(o => ({ el:o, left: parseFloat(o.style.left), top: parseFloat(o.style.top) }));
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!dragging) return;
    const dxpx = ev.clientX - dragStart.x;
    const dypx = ev.clientY - dragStart.y;
    // convert pixel movement to world movement (divide by scale)
    const dx = dxpx / scale, dy = dypx / scale;
    for(const o of groupOrig){
      let nx = o.left + dx, ny = o.top + dy;
      if(snapToggle.checked){ nx = snapValue(nx); ny = snapValue(ny); }
      o.el.style.left = nx + 'px'; o.el.style.top = ny + 'px';
    }
  });
  window.addEventListener('pointerup', (ev)=>{
    if(!dragging) return;
    dragging = false;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
  });

  // resize (single target)
  let resizing=false, rStart=null, rOrig=null;
  resizeHandle.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    resizing = true;
    rStart = { x: ev.clientX, y: ev.clientY };
    rOrig = { w: el.offsetWidth, h: el.offsetHeight };
    // ensure single selection (we resize the clicked element)
    if(!selectedSet.has(el)){ clearSelection(); addToSelection(el); }
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!resizing) return;
    const dxpx = ev.clientX - rStart.x;
    const dypx = ev.clientY - rStart.y;
    const dx = dxpx / scale, dy = dypx / scale;
    let nw = Math.max(20, rOrig.w + dx), nh = Math.max(12, rOrig.h + dy);
    if(snapToggle.checked){ nw = snapValue(nw); nh = snapValue(nh); }
    el.style.width = nw + 'px'; el.style.height = nh + 'px';
  });
  window.addEventListener('pointerup', (ev)=>{
    if(!resizing) return;
    resizing = false;
    resizeHandle.releasePointerCapture && resizeHandle.releasePointerCapture(ev.pointerId);
  });

  // rotate (single target) — store startAngle + startPointerAngle for stable rotation
  let rotating=false, rotateStartPointerAngle=0, rotateStartAngle=0, rotateCenter = null;
  rotateHandle.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
    rotating = true;
    // center in page coords for angle calc
    const rect = el.getBoundingClientRect();
    const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
    rotateCenter = pageToWorld(cx, cy);
    // starting angles
    rotateStartAngle = parseFloat(el.dataset.angle || '0');
    // compute pointer start angle relative to center
    const p = pageToWorld(ev.clientX, ev.clientY);
    rotateStartPointerAngle = Math.atan2(p.y - rotateCenter.y, p.x - rotateCenter.x) * 180 / Math.PI;
    // ensure single selection
    if(!selectedSet.has(el)){ clearSelection(); addToSelection(el); }
  });
  window.addEventListener('pointermove', (ev)=>{
    if(!rotating) return;
    const p = pageToWorld(ev.clientX, ev.clientY);
    const pointerAngle = Math.atan2(p.y - rotateCenter.y, p.x - rotateCenter.x) * 180 / Math.PI;
    let delta = pointerAngle - rotateStartPointerAngle;
    // new angle is startAngle + delta + 90 to align handle orientation
    let newAngle = rotateStartAngle + delta + 90;
    if(snapToggle.checked) newAngle = snapAngle(newAngle);
    el.style.transform = `rotate(${newAngle}deg)`;
    el.dataset.angle = String(newAngle);
  });
  window.addEventListener('pointerup', (ev)=>{
    if(!rotating) return;
    rotating = false;
    rotateHandle.releasePointerCapture && rotateHandle.releasePointerCapture(ev.pointerId);
  });

  // double-click to edit text
  el.addEventListener('dblclick', (ev)=>{
    if(el.classList.contains('text')){
      const c = el.querySelector('.content');
      c.contentEditable = true; c.focus();
      c.addEventListener('blur', ()=> c.contentEditable = false, { once:true });
    }
  });

  // click selects (shift toggles)
  el.addEventListener('click', (ev)=>{
    ev.stopPropagation();
    const append = ev.shiftKey;
    selectObjectSingle(el, append);
  });
}

/* duplicates and deletes for set-based selection */
function duplicateSelected(){
  const sel = getSelectionArray();
  if(sel.length === 0) return;
  clearSelection();
  for(const el of sel){
    const clone = el.cloneNode(true);
    clone.dataset.objId = 'obj' + (objectCounter++);
    const left = parseFloat(el.style.left || 0) + 20;
    const top  = parseFloat(el.style.top  || 0) + 20;
    clone.style.left = left + 'px'; clone.style.top = top + 'px';
    clone.style.zIndex = ++zCounter;
    // re-hook handles
    const rotateHandle = clone.querySelector('.handle.rotate') || (() => { const d=document.createElement('div'); d.className='handle rotate'; return d; })();
    const resizeHandle = clone.querySelector('.handle.resize') || (() => { const d=document.createElement('div'); d.className='handle resize'; return d; })();
    // ensure they exist inside clone
    if(!clone.querySelector('.handle.rotate')) clone.appendChild(rotateHandle);
    if(!clone.querySelector('.handle.resize')) clone.appendChild(resizeHandle);
    makeInteractiveObject(clone, rotateHandle, resizeHandle);
    objectsLayer.appendChild(clone);
    addToSelection(clone);
  }
}
function deleteSelected(){
  const sel = getSelectionArray();
  if(sel.length === 0) return;
  for(const el of sel) el.remove();
  clearSelection();
}

/* clicking empty area deselects */
viewport.addEventListener('pointerdown', (ev)=>{
  if(ev.target === viewport || ev.target === world || ev.target === drawingCanvas) {
    // handled in top-level pointerdown; here ensure deselect if clicking empty and not selecting/panning
    if(!spaceDown && drawMode === 'select'){
      // allow selection rectangle instead — do nothing
    } else if(drawMode !== 'pen' && drawMode !== 'highlighter' && drawMode !== 'eraser'){
      clearSelection();
    }
  }
});

/* --------------------
   Toolbar wiring
   -------------------- */
document.getElementById('addRect').addEventListener('click', ()=> createObject({ type:'rect' }));
document.getElementById('addCircle').addEventListener('click', ()=> createObject({ type:'circle', w:140, h:140 }));
document.getElementById('addText').addEventListener('click', ()=> createObject({ type:'text', w:220, h:80, html:'Double-click to edit' }));
document.getElementById('addImage').addEventListener('click', ()=>{
  const url = prompt('Image URL (direct)');
  if(!url) return;
  createObject({ type:'rect', w:260, h:160, html:`<img src="${url.replace(/"/g,'')}" alt="">` });
});
document.getElementById('dupBtn').addEventListener('click', ()=> duplicateSelected());
document.getElementById('clearAll').addEventListener('click', ()=> {
  if(confirm('Remove all objects and drawings?')){
    objectsLayer.innerHTML = '';
    ctx.clearRect(0,0,drawingCanvas.width,drawingCanvas.height);
    clearSelection();
  }
});

/* export/import JSON */
exportJSONBtn.addEventListener('click', ()=>{
  const out = [];
  for(const el of objectsLayer.children){
    if(!el.classList || !el.classList.contains('obj')) continue;
    out.push({
      id: el.dataset.objId,
      type: el.classList.contains('circle') ? 'circle' : el.classList.contains('text') ? 'text' : 'rect',
      left: parseFloat(el.style.left || 0),
      top: parseFloat(el.style.top || 0),
      width: parseFloat(el.style.width || el.offsetWidth),
      height: parseFloat(el.style.height || el.offsetHeight),
      angle: parseFloat(el.dataset.angle || 0),
      html: el.querySelector('.content').innerHTML,
      z: parseInt(el.style.zIndex || 0, 10)
    });
  }
  const blob = new Blob([JSON.stringify(out, null, 2)], { type:'application/json' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'whiteboard-objects.json'; a.click(); URL.revokeObjectURL(a.href);
});
importJSONbtn.addEventListener('click', ()=> importJSONfile.click());
importJSONfile.addEventListener('change', (ev)=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    try{
      const data = JSON.parse(e.target.result);
      objectsLayer.innerHTML = '';
      clearSelection();
      for(const item of data){
        const el = createObject({ x:item.left, y:item.top, w:item.width, h:item.height, type:item.type, html:item.html });
        el.style.zIndex = item.z || 1;
        el.style.transform = `rotate(${item.angle || 0}deg)`;
        el.dataset.angle = String(item.angle || 0);
      }
    } catch(err){ alert('Invalid JSON'); }
  };
  reader.readAsText(f);
  ev.target.value = '';
});

/* grid toggle */
toggleGridBtn.addEventListener('click', ()=> {
  const on = !world.classList.contains('grid');
  if(on) world.classList.add('grid'); else world.classList.remove('grid');
});

/* duplicate & delete keys and small bindings */
window.addEventListener('keydown', (ev)=>{
  // Duplicate already handled above; ensure we also check when selection exists
  if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'd'){ duplicateSelected(); ev.preventDefault(); }
  if(ev.key === 'Delete' || ev.key === 'Backspace'){ deleteSelected(); ev.preventDefault(); }
});

/* --------------------
   Selection rectangle: clicking Shift + drag adds to selection (handled) - finalized earlier
   -------------------- */

/* --------------------
   Guide restore/hide
   -------------------- */
const GUIDE_KEY = 'wb_guide_state_v3_fixed';
let guideState = { open:true };
try{ const s = localStorage.getItem(GUIDE_KEY); if(s) guideState = JSON.parse(s); }catch(e){}
function applyGuide(){ if(!guideState.open){ guide.style.display='none'; helpBtn.style.display='block'; } else { guide.style.display='block'; helpBtn.style.display='none'; } }
applyGuide();
collapseGuide.addEventListener('click', ()=>{ guideState.open = !guideState.open; localStorage.setItem(GUIDE_KEY, JSON.stringify(guideState)); applyGuide(); });
closeGuide.addEventListener('click', ()=>{ guideState.open = false; localStorage.setItem(GUIDE_KEY, JSON.stringify(guideState)); applyGuide(); });
helpBtn.addEventListener('click', ()=>{ guideState.open = true; localStorage.setItem(GUIDE_KEY, JSON.stringify(guideState)); applyGuide(); });

/* --------------------
   Initialize demo objects & final ui wiring
   -------------------- */
createObject({ x:80, y:60, w:260, h:150, type:'rect' });
createObject({ x:420, y:120, w:160, h:160, type:'circle' });
createObject({ x:120, y:320, w:260, h:110, type:'text', html:'Double-click to edit' });
resizeWorld();

/* Keep grid size variable updated */
gridSizeSelect.addEventListener('change', ()=> {/* snapping uses select value dynamically */});
snapToggle.addEventListener('change', ()=> {/* snapValue checks checkbox */});

/* Good-to-have: prevent touch scrolling while drawing in viewport */
document.body.addEventListener('touchstart', (e)=>{ if(e.target === drawingCanvas || e.target.closest('.world')) e.preventDefault(); }, { passive:false });
document.body.addEventListener('touchmove', (e)=>{ if(e.target === drawingCanvas || e.target.closest('.world')) e.preventDefault(); }, { passive:false });

</script>
</body>
</html>
